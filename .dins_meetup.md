Jenkins - сделать красивую картинку
Вопрос залу: Что это такое?
Это сервер автоматизации, и для чего же он нужен? Для процесса непрерывной интеграции.

Непрерывная интеграция это просто. Скачиваем Jenkins, устанавливаем его, создаем джобу, нажимаем кнопку, получаем оповещение на почту что билд сломан (предпалагается что у вас это автоматизировано). Потом исправляем тесты (предполагается что у вас есть тесты) и получаем уже более жизнерадостное пиьсмо о том, что билд прошел. После этого идем на конференцию и рассказываем о процессе непрерывной интеграции, о том как это круто, и что вам нужно следовать следующим принципам:
* Automate the Build
* Automate Deployment
* Test in a Clone of the Production Environment
* Keep the Build Fast
* Everyone can see what's happening

В начале все гладко и ровно. Проблемы начинаются потом ...

* Команда становится больше
* Больше изменений в системе
* Проект становится сложнее
Когда у вас система из сотни микросервисов написанных на разных языках автоматизировать их сборку и развертывание на окружении уже не так просто.
А само окружение становится очень большим, дорогим и нестабильным. На продакшене за окружением следят десятки и даже сотни инженеров, никто не будет уделять столько внимания тестовым окружениям.
* Количество тестов растет. Удерживать время сборки и прохождения тестов в приемлемых границах станвоится все сложнее, потому что  тестировщики пищут много end-to-end тестов, которые требуют большого окружения и выполняются часы и даже десятки часов, затем вы
строите суперархитектуры по запуску 500 e2e тестов на 50 агентах, чтобы все летало быстро (картинка с Thread.sleep(3000)), аж за полтора часа.
Но при этом билд никогда не бывает зеленым, всегда есть упавшие тесты, тестировщики начинают их категоризировать, помечать как ожидаемые, вместо того чтобы исправлять. Как при этом можно говорить о каком-либо неперывном процессе?
* Интегрировать изменения чаще. Но мы все ще хотим интегрировать изменения как можно чаще, в идеале - на каждый коммит, но инфраструкутра для этого будет слишком дорогой. Чем реже вы интегрируете изменения, тем реже вы выпускаете релизы, а значит они становятся больше и сложнее.


Вывод - все было так просто в начале и стало так паршиво сейчас, почему простые вещи перестали работать? Small is beautiful
Маленькие вещи стали огромными - с ними сложно. Надо вернуться обратно к простым вещам.
(Картинка - Small is beautiful). 
В программировании это решено с помощью микросервисов, модулей, классов, методов, функций... (картинка с говняшками - много маленьких лучше чем одно большое). Этот же подход необходимо применить и к CI как со стороны процесса, так и со стороны инструментов. 

Начнем с процесса
В 90-х когда формировались принципы непрерывной интеграции - оснавная проблема была как интегрировать изменения от большого числа разработчиков в рамках одного репозитория (тогда были монолиты?). Но сейчас 2017 год. 
Современные продукты состоят из систем, которые состоят из компонентов, которые состоят из микросервисов (картинка с кругами goto conference Small is beautiful). И каждый микросервис живет в своем собственном репозитории, его размер такой, что он должен помещаться в голове одного разработчика (вопрос к залу?). (работает 1 разработчик)
Проблемы интеграции в рамках одного репозитория нет. Она перешла на другие уровни - интеграцию микросервисов, компонентов и систем в рамках продукта. (все еще картинка с кругами)
Как в этой ситуации организовать процесс CI? - переход на картинку MSCI.
Применяем концепцию MSCI. На каждом этапе цикла разработки нашего продукта мы работаем с разными уровнями. При разработке микросервиса интегрируем изменения от нескольких разработчиков. Потом интегрируем микросервисы в компоненты, компоненты в системы, а системы в продукт. И на каждом этапе нужен свой отдельный процесс непрерывной интеграции.
Таким образом вместо одного большого и сложного этапа непрерывной интеграции всех со всеми мы получаем процесс составленый из множества маленьких и простых этапов.

Вроде с процессом все понятно. Что же делать с инструментами? Как сделать большой Jenkins снова маленьким?


### Использование большого количества технологий
Проблема: Микросервисный подход и рост команды подразумевает использование разных стэков технологий, и это требует поддержки на слэйвах. Они будут либо превращены в помойку, содержащую разные пакеты и версии, или наоборот будут узкоспециализированными. Конфигурация джоб становится сложнее, тебуется множество дополнтельных плагинов. Нужен отдельны оркестратор чтобы обновлять версии библитек на слэйвах. 
Решение: Задаем конфигурацию слэйвов через Docker и отдаем ее команде разработки. 

### Низкая утилизация ресурсов
Проблема: Во время релиза очередь на Jenkins постоянно занята и требует много ресурсов, а остальное время простаивают. А также не забывать постоянно чистить место на слэйвах.
Решение: Используем облачную инфраструктуру (например Mesos и Jenkins Mesos Plugin) для динамического создания и удаление слэйвов. Это позваляет использовать ресурсы как агенты только когда это надо, в остальное время они могут использоваться для других целей. Вы вообще не занимаетесь поддержкой слэйвов.

### Высокая нагрузка на мастера
Проблема: Данные со слэйвов стекаются на Jenkins мастер (логи, отчеты, артефакты, мониторинг слэйвов), поэтому производительность мастера падает, Jenkins это не CDN. Когда что-то пошло не так на CI сервере нужны логи джобы. А если это большой регрессионный прогон, то логов может быть десятки мегабайт. Браузер тупит, поиск тупит, анализировать невозможно.  
Решение: Пишем сразу во внешние системы: логи - Elasticserach, отчеты по тестированию - объектное хранилище, артефакты - Nexus, в результатах сохраняем только ссылки.

### Один мастер для всех команд
Проблема: Использование одного Jenkins мастера неудобно когда работает множество команд. К этому моменты мы уже вынесли с мастера все что можно, но все равно его возможности ограничены количеством запущенных джоб и агентов. А также не стоит забывать про обновления мастера и плагинов, использование groovy system script (требуется согласование), всем админские права не дать. Если не работает этот один мастер, не работает вся компания.
Решение: Jenkins в каждый дом (на слайд). Jenkins мастер в Docker и переносим в Mesos + Marathon (единый пул ресурсов). Предоставляем на каждый этап и каждой команде отдельный мастер, при этом у всех единый пул ресурсов для динамического создания агентов. Мастер хранит свои данные вне контейнера (например docker volume).

### Предоставлять окружение только в нужный момент
Проблема: Каждый этап разработки требует свое собственное окружение разного размера. Поддерживать все большее количество таких окружений будет стоить дорого.
Решение: Используем инфраструктуру Mesos + Marathon для развертывания тестовых окружений через СI. Раскрыть тему - вернуться к этапам. 

Пример

